import nock from 'nock';
import request from 'supertest';
import { Express } from 'express';
import {
  MockLensSelectorClient,
  MockPreprocessorClient,
  MockFhirClient,
  getEpiFixture,
  getIpsFixture,
  getPvFixture,
  getLensFixture,
  extractLensCode,
  getEpiIdFromFixture,
  getPatientIdFromIpsFixture,
} from './helpers/mockClients';
import { ServiceClientFactory } from '../src/utils/ServiceClientFactory';
import { createTestApp } from './helpers/testApp';

describe('Focusing Manager - Focus Endpoint', () => {
  let app: Express;
  let epiFixtureJson: any;
  let ipsFixture: any;
  let pvFixtureJson: any;
  let pregnancyLens: any;
  let conditionsLens: any;
  let mockLensClient: MockLensSelectorClient;
  let mockPreprocessorClient: MockPreprocessorClient;
  let mockFhirClient: MockFhirClient;
  let epiId: string;
  let patientId: string;

  beforeAll(() => {
    // Create Express app for testing
    app = createTestApp();
    
    // Load all fixtures once
    epiFixtureJson = getEpiFixture('json');
    ipsFixture = getIpsFixture();
    pvFixtureJson = getPvFixture('json');
    pregnancyLens = getLensFixture('pregnancy');
    conditionsLens = getLensFixture('conditions');
    
    // Extract IDs from fixtures
    epiId = getEpiIdFromFixture(epiFixtureJson);
    patientId = getPatientIdFromIpsFixture(ipsFixture);
    
    // Create specialized mock clients
    mockLensClient = new MockLensSelectorClient();
    mockPreprocessorClient = new MockPreprocessorClient();
    mockFhirClient = new MockFhirClient();
  });

  beforeEach(() => {
    // Clean up any pending mocks
    nock.cleanAll();
    
    // Mock ServiceClientFactory to return appropriate client
    // The LensesProvider and PreprocessingProvider call this separately
    // We need to return a unified client that works for both
    let callCount = 0;
    jest.spyOn(ServiceClientFactory, 'getClient').mockImplementation(async () => {
      callCount++;
      // First call is usually for lenses, second for preprocessing
      // But to be safe, return a client that works for both
      return callCount % 2 === 1 ? mockLensClient : mockPreprocessorClient;
    });
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Test Combinations: ePI, IPS, and PV variations', () => {
    /**
     * Test matrix:
     * - ePI: implicit (in request body) vs referenced (by ID)
     * - IPS: implicit (in request body) vs referenced (by patient ID)
     * - PV: implicit (in request body) vs referenced (by ID) vs none
     * - Formats: JSON, XML, TTL (where applicable)
     */

    describe('Scenario 1: All implicit (ePI + IPS + PV in request body)', () => {
      test('should focus with implicit ePI JSON, IPS JSON, and PV JSON', async () => {
        // Mock ServiceClientFactory to return lens client
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient) // For lens discovery
          .mockResolvedValueOnce(mockPreprocessorClient); // For preprocessor discovery

        // Mock lens service responses
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens, conditionsLens]);

        // Mock preprocessing service
        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Mock individual lens fetches
        const pregnancyCode = extractLensCode(pregnancyLens);
        const conditionsCode = extractLensCode(conditionsLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });
        nock('http://mock-lens-service.test')
          .get(`/lenses/${conditionsLens.id}`)
          .reply(200, { code: Buffer.from(conditionsCode).toString('base64') });

        // Call the actual API endpoint
        const response = await request(app)
          .post('/focus')
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture,
            pv: pvFixtureJson
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        // Verify response
        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
        // The response should contain the focused ePI
        expect(response.body.resourceType).toBeDefined();
      });

      test('should focus with implicit ePI XML format', async () => {
        const epiXml = getEpiFixture('xml');
        
        expect(epiXml).toBeDefined();
        expect(typeof epiXml).toBe('string');
        expect(epiXml).toContain('<?xml');
      });

      test('should focus with implicit ePI TTL format', async () => {
        const epiTtl = getEpiFixture('ttl');
        
        expect(epiTtl).toBeDefined();
        expect(typeof epiTtl).toBe('string');
        expect(epiTtl).toContain('@prefix');
      });

      test('should focus with implicit IPS XML format', async () => {
        const ipsXml = getIpsFixture('xml');
        
        expect(ipsXml).toBeDefined();
        expect(typeof ipsXml).toBe('string');
        expect(ipsXml).toContain('<Bundle');
      });

      test('should focus with implicit IPS TTL format', async () => {
        const ipsTtl = getIpsFixture('ttl');
        
        expect(ipsTtl).toBeDefined();
        expect(typeof ipsTtl).toBe('string');
        expect(ipsTtl).toContain('@prefix');
      });
    });

    describe('Scenario 2: Referenced ePI by ID (implicit IPS + PV)', () => {
      test('should focus with ePI ID, implicit IPS and PV', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock FHIR server response for ePI fetch
        nock(mockFhirClient.getServerUrl('epi'))
          .get(`/Bundle/${epiId}`)
          .reply(200, epiFixtureJson);

        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens]);

        const pregnancyCode = extractLensCode(pregnancyLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with ePI ID
        const response = await request(app)
          .post(`/focus/${epiId}`)
          .send({
            ips: ipsFixture,
            pv: pvFixtureJson
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 3: Referenced IPS by patient ID (implicit ePI + PV)', () => {
      test('should focus with patientIdentifier, implicit ePI and PV', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock FHIR server response for IPS fetch
        nock(mockFhirClient.getServerUrl('ips'))
          .get(`/Patient/${patientId}/$summary`)
          .reply(200, ipsFixture);

        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [conditionsLens]);

        const conditionsCode = extractLensCode(conditionsLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${conditionsLens.id}`)
          .reply(200, { code: Buffer.from(conditionsCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with patient ID
        const response = await request(app)
          .post('/focus')
          .query({ patientIdentifier: patientId })
          .send({
            epi: epiFixtureJson,
            pv: pvFixtureJson
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 4: Referenced PV by ID (implicit ePI + IPS)', () => {
      test('should focus with PV ID, implicit ePI and IPS', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        const pvId = 'pedro-dimension-collection';
        
        // Mock profile server response for PV fetch
        nock(mockFhirClient.getServerUrl('pv'))
          .get(`/Bundle/${pvId}`)
          .reply(200, pvFixtureJson);

        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens]);

        const pregnancyCode = extractLensCode(pregnancyLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with PV ID
        const response = await request(app)
          .post('/focus')
          .query({ pvId: pvId })
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 5: No PV (ePI + IPS only)', () => {
      test('should focus without PV (implicit ePI and IPS)', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens]);

        const pregnancyCode = extractLensCode(pregnancyLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint without PV
        const response = await request(app)
          .post('/focus')
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });

      test('should focus without PV (referenced ePI and IPS)', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock FHIR servers
        nock(mockFhirClient.getServerUrl('epi'))
          .get(`/Bundle/${epiId}`)
          .reply(200, epiFixtureJson);

        nock(mockFhirClient.getServerUrl('ips'))
          .get(`/Patient/${patientId}/$summary`)
          .reply(200, ipsFixture);

        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [conditionsLens]);

        const conditionsCode = extractLensCode(conditionsLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${conditionsLens.id}`)
          .reply(200, { code: Buffer.from(conditionsCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with IDs, no PV
        const response = await request(app)
          .post(`/focus/${epiId}`)
          .query({ patientIdentifier: patientId })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 6: All referenced (ePI ID + patient ID + PV ID)', () => {
      test('should focus with all resources referenced by ID', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        const pvId = 'pedro-dimension-collection';
        
        // Mock all FHIR servers
        nock(mockFhirClient.getServerUrl('epi'))
          .get(`/Bundle/${epiId}`)
          .reply(200, epiFixtureJson);

        nock(mockFhirClient.getServerUrl('ips'))
          .get(`/Patient/${patientId}/$summary`)
          .reply(200, ipsFixture);

        nock(mockFhirClient.getServerUrl('pv'))
          .get(`/Bundle/${pvId}`)
          .reply(200, pvFixtureJson);

        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens, conditionsLens]);

        const pregnancyCode = extractLensCode(pregnancyLens);
        const conditionsCode = extractLensCode(conditionsLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });
        nock('http://mock-lens-service.test')
          .get(`/lenses/${conditionsLens.id}`)
          .reply(200, { code: Buffer.from(conditionsCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with all IDs
        const response = await request(app)
          .post(`/focus/${epiId}`)
          .query({ 
            patientIdentifier: patientId,
            pvId: pvId 
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 7: Different file formats for PV', () => {
      test('should handle PV in XML format', async () => {
        const pvXml = getPvFixture('xml');
        
        expect(pvXml).toBeDefined();
        expect(typeof pvXml).toBe('string');
        expect(pvXml).toContain('<?xml');
      });

      test('should handle PV in TTL format', async () => {
        const pvTtl = getPvFixture('ttl');
        
        expect(pvTtl).toBeDefined();
        expect(typeof pvTtl).toBe('string');
        expect(pvTtl).toContain('@prefix');
      });
    });

    describe('Scenario 8: Specific lens selection', () => {
      test('should apply only pregnancy lens when specified', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens, conditionsLens]); // Service returns all

        const pregnancyCode = extractLensCode(pregnancyLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with lens filter
        const response = await request(app)
          .post('/focus')
          .query({ lenses: 'pregnancy' }) // Client filters to specific lens
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });

      test('should apply multiple specific lenses when specified', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock lens services
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens, conditionsLens]);

        const pregnancyCode = extractLensCode(pregnancyLens);
        const conditionsCode = extractLensCode(conditionsLens);
        nock('http://mock-lens-service.test')
          .get(`/lenses/${pregnancyLens.id}`)
          .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });
        nock('http://mock-lens-service.test')
          .get(`/lenses/${conditionsLens.id}`)
          .reply(200, { code: Buffer.from(conditionsCode).toString('base64') });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint with multiple lenses
        const response = await request(app)
          .post('/focus')
          .query({ lenses: 'pregnancy,conditions' })
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        expect(response.status).toBe(200);
        expect(response.body).toBeDefined();
      });
    });

    describe('Scenario 9: Error handling', () => {
      test('should handle FHIR server errors gracefully', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock FHIR server error
        nock(mockFhirClient.getServerUrl('epi'))
          .get(`/Bundle/${epiId}`)
          .reply(404, { error: 'Resource not found' });

        // Call the actual API endpoint and expect error
        const response = await request(app)
          .post(`/focus/${epiId}`)
          .send({ ips: ipsFixture })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        // Expect error status (400, 404, or 500)
        expect([400, 404, 500]).toContain(response.status);
      });

      test('should handle lens service errors gracefully', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock lens service error
        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(500, { error: 'Internal server error' });

        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(200, epiFixtureJson);

        // Call the actual API endpoint
        const response = await request(app)
          .post('/focus')
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        // May succeed with warning or fail gracefully
        expect([200, 500]).toContain(response.status);
      });

      test('should handle preprocessing errors gracefully', async () => {
        // Mock ServiceClientFactory
        jest.spyOn(ServiceClientFactory, 'getClient')
          .mockResolvedValueOnce(mockLensClient)
          .mockResolvedValueOnce(mockPreprocessorClient);
        
        // Mock preprocessing error
        nock('http://mock-preprocessing-service.test')
          .post(/.*/)
          .reply(500, { error: 'Preprocessing failed' });

        nock('http://mock-lens-service.test')
          .get('/lenses')
          .reply(200, [pregnancyLens]);

        // Call the actual API endpoint
        const response = await request(app)
          .post('/focus')
          .send({
            epi: epiFixtureJson,
            ips: ipsFixture
          })
          .set('Content-Type', 'application/json')
          .set('Accept', 'application/json');

        // May return original ePI or error
        expect([200, 500]).toContain(response.status);
      });
    });
  });

  describe('Response Format Tests', () => {
    test('should return JSON response when Accept: application/json', async () => {
      // Mock ServiceClientFactory
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(mockLensClient)
        .mockResolvedValueOnce(mockPreprocessorClient);
      
      nock('http://mock-lens-service.test')
        .get('/lenses')
        .reply(200, [pregnancyLens]);

      const pregnancyCode = extractLensCode(pregnancyLens);
      nock('http://mock-lens-service.test')
        .get(`/lenses/${pregnancyLens.id}`)
        .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

      nock('http://mock-preprocessing-service.test')
        .post(/.*/)
        .reply(200, epiFixtureJson);

      // Call with JSON Accept header
      const response = await request(app)
        .post('/focus')
        .send({
          epi: epiFixtureJson,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json');

      expect(response.status).toBe(200);
      expect(response.type).toMatch(/json/);
      expect(response.body).toBeDefined();
      expect(typeof response.body).toBe('object');
    });

    test('should return HTML response when Accept: text/html', async () => {
      // Mock ServiceClientFactory
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(mockLensClient)
        .mockResolvedValueOnce(mockPreprocessorClient);
      
      nock('http://mock-lens-service.test')
        .get('/lenses')
        .reply(200, [pregnancyLens]);

      const pregnancyCode = extractLensCode(pregnancyLens);
      nock('http://mock-lens-service.test')
        .get(`/lenses/${pregnancyLens.id}`)
        .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

      nock('http://mock-preprocessing-service.test')
        .post(/.*/)
        .reply(200, epiFixtureJson);

      // Call with HTML Accept header
      const response = await request(app)
        .post('/focus')
        .send({
          epi: epiFixtureJson,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'text/html');

      expect(response.status).toBe(200);
      expect(response.type).toMatch(/html/);
      expect(typeof response.text).toBe('string');
      expect(response.text).toContain('<'); // Basic HTML check
    });
  });

  describe('Preprocessing Tests', () => {
    test('should skip preprocessing if ePI category is "P" (preprocessed)', async () => {
      // Create an ePI with category "P"
      const preprocessedEpi = JSON.parse(JSON.stringify(epiFixtureJson));
      // Set category to "P" - locate Composition and set category
      if (preprocessedEpi.entry) {
        const composition = preprocessedEpi.entry.find((e: any) => e.resource?.resourceType === 'Composition');
        if (composition?.resource?.category) {
          composition.resource.category[0].coding[0].code = 'P';
        }
      }

      // Mock ServiceClientFactory
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(mockLensClient)
        .mockResolvedValueOnce(mockPreprocessorClient);
      
      nock('http://mock-lens-service.test')
        .get('/lenses')
        .reply(200, [pregnancyLens]);

      const pregnancyCode = extractLensCode(pregnancyLens);
      nock('http://mock-lens-service.test')
        .get(`/lenses/${pregnancyLens.id}`)
        .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

      // Note: No preprocessing mock needed - should skip preprocessing

      const response = await request(app)
        .post('/focus')
        .send({
          epi: preprocessedEpi,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json');

      expect(response.status).toBe(200);
      // Verify preprocessing was skipped (no POST to preprocessing service)
      expect(nock.isDone()).toBe(true);
    });

    test('should run preprocessing if ePI category is "R" (raw)', async () => {
      // Create an ePI with category "R"
      const rawEpi = JSON.parse(JSON.stringify(epiFixtureJson));
      // Set category to "R" - locate Composition and set category
      if (rawEpi.entry) {
        const composition = rawEpi.entry.find((e: any) => e.resource?.resourceType === 'Composition');
        if (composition?.resource?.category) {
          composition.resource.category[0].coding[0].code = 'R';
        }
      }

      // Mock ServiceClientFactory
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(mockLensClient)
        .mockResolvedValueOnce(mockPreprocessorClient);
      
      nock('http://mock-lens-service.test')
        .get('/lenses')
        .reply(200, [pregnancyLens]);

      const pregnancyCode = extractLensCode(pregnancyLens);
      nock('http://mock-lens-service.test')
        .get(`/lenses/${pregnancyLens.id}`)
        .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

      // Mock preprocessing service - should be called
      nock('http://mock-preprocessing-service.test')
        .post(/.*/)
        .reply(200, epiFixtureJson);

      const response = await request(app)
        .post('/focus')
        .send({
          epi: rawEpi,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json');

      expect(response.status).toBe(200);
      // Verify preprocessing was called
      expect(nock.isDone()).toBe(true);
    });
  });

  describe('Service Discovery Tests', () => {
    test('should discover lens services using mock lens client', async () => {
      const lensUrls = await mockLensClient.getServiceBaseUrlsByLabel('focusing');
      
      expect(lensUrls).toBeDefined();
      expect(lensUrls.length).toBeGreaterThan(0);
      expect(lensUrls[0]).toContain('mock-lens-service');
    });

    test('should discover preprocessing services using mock preprocessor client', async () => {
      const preprocessingUrls = await mockPreprocessorClient.getServiceBaseUrlsByLabel('preprocessing');
      
      expect(preprocessingUrls).toBeDefined();
      expect(preprocessingUrls.length).toBeGreaterThan(0);
      expect(preprocessingUrls[0]).toContain('mock-preprocessing-service');
    });

    test('should get FHIR server URLs from mock FHIR client', async () => {
      expect(mockFhirClient.getServerUrl('epi')).toContain('mock-fhir-epi');
      expect(mockFhirClient.getServerUrl('ips')).toContain('mock-fhir-ips');
      expect(mockFhirClient.getServerUrl('pv')).toContain('mock-profile');
    });

    test('should handle no preprocessors discovered', async () => {
      // Mock ServiceClientFactory to return empty preprocessor client
      const emptyPreprocessorClient = new MockPreprocessorClient([]);
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(mockLensClient)
        .mockResolvedValueOnce(emptyPreprocessorClient);
      
      nock('http://mock-lens-service.test')
        .get('/lenses')
        .reply(200, [pregnancyLens]);

      const pregnancyCode = extractLensCode(pregnancyLens);
      nock('http://mock-lens-service.test')
        .get(`/lenses/${pregnancyLens.id}`)
        .reply(200, { code: Buffer.from(pregnancyCode).toString('base64') });

      // Call the actual API endpoint - should handle gracefully
      const response = await request(app)
        .post('/focus')
        .send({
          epi: epiFixtureJson,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json');

      // Should either succeed with warning or return original ePI
      expect([200, 500]).toContain(response.status);
    });

    test('should handle no lens selectors discovered', async () => {
      // Mock ServiceClientFactory to return empty lens client
      const emptyLensClient = new MockLensSelectorClient([]);
      jest.spyOn(ServiceClientFactory, 'getClient')
        .mockResolvedValueOnce(emptyLensClient)
        .mockResolvedValueOnce(mockPreprocessorClient);
      
      nock('http://mock-preprocessing-service.test')
        .post(/.*/)
        .reply(200, epiFixtureJson);

      // Call the actual API endpoint - should handle gracefully
      const response = await request(app)
        .post('/focus')
        .send({
          epi: epiFixtureJson,
          ips: ipsFixture
        })
        .set('Content-Type', 'application/json')
        .set('Accept', 'application/json');

      // Should succeed with preprocessing but no lenses applied
      expect([200, 500]).toContain(response.status);
    });
  });
});
